<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>세계지도 학습</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Noto Sans KR', sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; overflow: hidden; }
        .container { width: 100vw; height: 100vh; position: relative; display: flex; flex-direction: column; }
        .header { background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px); padding: 15px 20px; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1); display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px; z-index: 10; }
        .title { font-size: 1.5rem; font-weight: 700; color: #2c3e50; }
        .controls { display: flex; gap: 15px; align-items: center; flex-wrap: wrap; }
        .control-group { display: flex; align-items: center; gap: 8px; background: rgba(255, 255, 255, 0.7); padding: 8px 12px; border-radius: 20px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); }
        .toggle { position: relative; display: inline-block; width: 50px; height: 24px; }
        .toggle input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 24px; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #4CAF50; }
        input:checked + .slider:before { transform: translateX(26px); }
        .size-slider { width: 120px; }
        .btn { background: linear-gradient(45deg, #667eea, #764ba2); color: white; border: none; padding: 8px 16px; border-radius: 20px; cursor: pointer; font-family: 'Noto Sans KR', sans-serif; font-weight: 500; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3); }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4); }
        .map-wrapper { flex: 1; overflow: auto; }
        .map-container { position: relative; background: linear-gradient(to bottom, #87CEEB 0%, #98D4EA 50%, #87CEEB 100%); }
        #worldMap { cursor: grab; display: block; }
        #worldMap:active { cursor: grabbing; }
        .loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(255, 255, 255, 0.9); padding: 20px 40px; border-radius: 10px; font-size: 1.2rem; font-weight: 500; color: #2c3e50; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2); }
        .country { stroke-width: 0.5; stroke: #333; transition: all 0.1s ease-in-out; }
        .country-hover { stroke-width: 1.5; stroke: #c0392b; filter: brightness(1.1); }
        .grid-line { fill: none; stroke: #666; stroke-width: 0.2; opacity: 0.5; pointer-events: none; }
        .country-label { font-family: 'Noto Sans KR', sans-serif; text-anchor: middle; fill: #2c3e50; font-weight: 600; pointer-events: none; paint-order: stroke; stroke: white; stroke-linejoin: round; transition: all 0.1s ease-in-out; }
        /* [추가] 이름 라벨 호버 효과 CSS */
        .label-hover { fill: #c0392b; stroke: #c0392b; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="title">🌍 세계지도 학습</div>
            <div class="controls">
                <div class="control-group"><label>나라 이름</label><label class="toggle"><input type="checkbox" id="showLabels" checked><span class="slider"></span></label></div>
                <div class="control-group"><label>글자 크기</label><input type="range" id="fontSize" class="size-slider" min="8" max="48" value="9"><span id="fontSizeValue">9px</span></div>
                <div class="control-group"><label>지도 크기</label><input type="range" id="mapSize" class="size-slider" min="1200" max="60000" value="1200" step="100"><span id="mapSizeValue">1200x600px</span></div>
                <button class="btn" onclick="downloadPNG()">PNG 다운로드</button>
                <button class="btn" onclick="downloadSVG()">SVG 다운로드</button>
            </div>
        </div>
        <div class="map-wrapper">
            <div class="map-container" id="mapContainer">
                <div class="loading" id="loadingIndicator">지도 데이터를 불러오는 중...</div>
                <svg id="worldMap"></svg>
            </div>
        </div>
    </div>

    <script>
        let currentScale = 1, currentX = 0, currentY = 0;
        let isDragging = false, dragStart = { x: 0, y: 0 }, panStart = { x: 0, y: 0 };
        let worldData = null;
        let mapWidth = 1200, mapHeight = 600;

        const pastelColors = [ '#FFB3BA', '#FFDFBA', '#FFFFBA', '#BAFFC9', '#BAE1FF', '#E0BBE4', '#FFC3A0', '#B5EAD7', '#C7CEEA', '#FFDAB9' ];
        const countryNames = { "AF": "아프가니스탄", "AO": "앙골라", "AL": "알바니아", "AE": "아랍에미리트", "AR": "아르헨티나", "AM": "아르메니아", "TF": "프랑스령 남방 및 남극", "AU": "호주", "AT": "오스트리아", "AZ": "아제르바이잔", "BI": "부룬디", "BE": "벨기에", "BJ": "베냉", "BF": "부르키나파소", "BD": "방글라데시", "BG": "불가리아", "BA": "보스니아 헤르체고비나", "BY": "벨라루스", "BZ": "벨리즈", "BM": "버뮤다", "BO": "볼리비아", "BR": "브라질", "BN": "브루나이", "BT": "부탄", "BW": "보츠와나", "CF": "중앙아프리카 공화국", "CA": "캐나다", "CH": "스위스", "CL": "칠레", "CN": "중국", "CI": "코트디부아르", "CM": "카메룬", "CD": "콩고 민주 공화국", "CG": "콩고 공화국", "CO": "콜롬비아", "CR": "코스타리카", "CU": "쿠바", "CY": "키프로스", "CZ": "체코", "DE": "독일", "DJ": "지부티", "DK": "덴마크", "DO": "도미니카 공화국", "DZ": "알제리", "EC": "에콰도르", "EG": "이집트", "ER": "에리트레아", "ES": "스페인", "EE": "에스토니아", "ET": "에티오피아", "FI": "핀란드", "FJ": "피지", "GA": "가봉", "GB": "영국", "GE": "조지아", "GH": "가나", "GN": "기니", "GM": "감비아", "GW": "기니비사우", "GQ": "적도 기니", "GR": "그리스", "GL": "그린란드", "GT": "과테말라", "GY": "가이아나", "HN": "온두라스", "HR": "크로아티아", "HT": "아이티", "HU": "헝가리", "ID": "인도네시아", "IN": "인도", "IE": "아일랜드", "IR": "이란", "IQ": "이라크", "IS": "아이슬란드", "IL": "이스라엘", "IT": "이탈리아", "JM": "자메이카", "JO": "요르단", "JP": "일본", "KZ": "카자흐스탄", "KE": "케냐", "KG": "키르기스스탄", "KH": "캄보디아", "KR": "대한민국", "XK": "코소보", "KW": "쿠웨이트", "LA": "라오스", "LB": "레바논", "LR": "라이베리아", "LY": "리비아", "LK": "스리랑카", "LS": "레소토", "LT": "리투아니아", "LU": "룩셈부르크", "LV": "라트비아", "MA": "모로코", "MD": "몰도바", "MG": "마다가스카르", "MX": "멕시코", "MK": "북마케도니아", "ML": "말리", "MM": "미얀마", "ME": "몬테네그로", "MN": "몽골", "MZ": "모잠비크", "MR": "모리타니", "MW": "말라위", "MY": "말레이시아", "NA": "나미비아", "NC": "누벨칼레도니", "NE": "니제르", "NG": "나이지리아", "NI": "니카라과", "NL": "네덜란드", "NO": "노르웨이", "NP": "네팔", "NZ": "뉴질랜드", "OM": "오만", "PK": "파키스탄", "PA": "파나마", "PE": "페루", "PH": "필리핀", "PG": "파푸아뉴기니", "PL": "폴란드", "PR": "푸에르토리코", "KP": "조선민주주의인민공화국", "PT": "포르투갈", "PY": "파라과이", "QA": "카타르", "RO": "루마니아", "RU": "러시아", "RW": "르완다", "EH": "서사하라", "SA": "사우디아라비아", "SD": "수단", "SS": "남수단", "SN": "세네갈", "SB": "솔로몬 제도", "SL": "시에라리온", "SV": "엘살바도르", "SO": "소말리아", "RS": "세르비아", "SR": "수리남", "SK": "슬로바키아", "SI": "슬로베니아", "SE": "스웨덴", "SZ": "에스와티니", "SY": "시리아", "TD": "차드", "TG": "토고", "TH": "태국", "TJ": "타지키스탄", "TM": "투르크메니스탄", "TL": "동티모르", "TT": "트리니다드 토바고", "TN": "튀니지", "TR": "터키", "TW": "대만", "TZ": "탄자니아", "UG": "우간다", "UA": "우크라이나", "UY": "우루과이", "US": "미국", "UZ": "우즈베키스탄", "VE": "베네수엘라", "VN": "베트남", "VU": "바누아투", "PS": "팔레스타인", "YE": "예멘", "ZA": "남아프리카 공화국", "ZM": "잠비아", "ZW": "짐바브웨", "AW": "아루바", "AI": "앵귈라", "AS": "아메리칸사모아", "AG": "앤티가 바부다", "BH": "바레인", "BB": "바베이도스", "BL": "생바르텔레미", "BS": "바하마", "IO": "영국령 인도양 지역", "KY": "케이맨 제도", "KM": "코모로", "CV": "카보베르데", "CK": "쿡 제도", "CW": "퀴라소", "DM": "도미니카 연방", "FK": "포클랜드 제도", "FO": "페로 제도", "FM": "미크로네시아 연방", "GD": "그레나다", "GU": "괌", "GG": "건지", "HK": "홍콩", "IM": "맨섬", "JE": "저지", "KI": "키리바시", "KN": "세인트키츠 네비스", "LC": "세인트루시아", "LI": "리히텐슈타인", "MO": "마카오", "MF": "생마르탱", "MV": "몰디브", "MS": "몬트세랫", "MU": "모리셔스", "MP": "북마리아나 제도", "MT": "몰타", "NU": "니우에", "NR": "나우루", "PN": "핏케언 제도", "PW": "팔라우", "SM": "산마리노", "ST": "상투메 프린시페", "SC": "세이셸", "SG": "싱가포르", "SH": "세인트헬레나", "SX": "신트마르턴", "TC": "터크스 케이커스 제도", "TO": "통가", "TV": "투발루", "VC": "세인트빈센트 그레나딘", "VG": "영국령 버진아일랜드", "VI": "미국령 버진아일랜드", "WS": "사모아" };

        const mercatorProjection = (lon, lat) => [(lon + 180) * (mapWidth / 360), (mapHeight / 2) - (mapWidth / (2 * Math.PI)) * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))];
        const geoJsonToSvgPath = (coordinates, type) => {
            let path = '';
            if (type === 'Polygon') path = coordinates.map(ring => 'M' + ring.map(p => mercatorProjection(p[0], p[1]).join(',')).join('L') + 'Z').join('');
            else if (type === 'MultiPolygon') path = coordinates.map(polygon => polygon.map(ring => 'M' + ring.map(p => mercatorProjection(p[0], p[1]).join(',')).join('L') + 'Z').join('')).join('');
            return path;
        };
        const getPolygonArea = coords => {
            let area = 0;
            for (let i = 0; i < coords.length; i++) {
                const [x1, y1] = mercatorProjection(coords[i][0], coords[i][1]);
                const [x2, y2] = mercatorProjection(coords[(i + 1) % coords.length][0], coords[(i + 1) % coords.length][1]);
                area += x1 * y2 - x2 * y1;
            }
            return Math.abs(area / 2);
        };

        async function loadWorldData() {
            const loadingIndicator = document.getElementById('loadingIndicator');
            try {
                const response = await fetch('https://raw.githubusercontent.com/martynafford/natural-earth-geojson/refs/heads/master/50m/cultural/ne_50m_admin_0_countries.json');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                worldData = await response.json();
                worldData.features.forEach(f => {
                    if (!f.geometry) return;
                    const largestPart = f.geometry.type === 'Polygon' ? f.geometry.coordinates[0] : f.geometry.coordinates.reduce((a, b) => a.flat().length > b.flat().length ? a : b, [])[0];
                    f.properties.calculatedArea = largestPart ? getPolygonArea(largestPart) : 0;
                });
                worldData.features.sort((a, b) => b.properties.calculatedArea - a.properties.calculatedArea);
                loadingIndicator.style.display = 'none';
                initMap();
            } catch (error) {
                loadingIndicator.textContent = '지도 데이터 로드에 실패했습니다.';
            }
        }
        
        function initMap() {
            const svg = document.getElementById('worldMap');
            const mapContainer = document.getElementById('mapContainer');
            svg.setAttribute('width', mapWidth);
            svg.setAttribute('height', mapHeight);
            svg.setAttribute('viewBox', `0 0 ${mapWidth} ${mapHeight}`);
            mapContainer.style.width = mapWidth + 'px';
            mapContainer.style.height = mapHeight + 'px';
            svg.innerHTML = `<g id="gridLines"></g><g id="countries"></g><g id="countryLabels"></g>`;
            drawMap();
            updateDynamicSizes();
        }

        function drawMap() {
            if (!worldData) return;
            const countryGroup = document.getElementById('countries');
            const labelGroup = document.getElementById('countryLabels');
            const placedLabelBoxes = [];

            worldData.features.forEach((feature, index) => {
                const { properties, geometry } = feature;
                if (!geometry || properties.ISO_A2 === '-99') return;

                const countryCode = properties.ISO_A2;
                const countryName = countryNames[countryCode] || properties.ADMIN;

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', geoJsonToSvgPath(geometry.coordinates, geometry.type));
                path.setAttribute('class', 'country');
                path.setAttribute('fill', pastelColors[index % pastelColors.length]);
                path.dataset.countryCode = countryCode;
                countryGroup.appendChild(path);

                if (countryName) {
                    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    const largestPart = geometry.type === 'Polygon' ? geometry.coordinates[0] : geometry.coordinates.reduce((a, b) => a.flat().length > b.flat().length ? a : b)[0];
                    const centerLonLat = getPolygonCenter(largestPart);
                    const [x, y] = mercatorProjection(centerLonLat[0], centerLonLat[1]);
                    
                    label.setAttribute('x', x);
                    label.setAttribute('y', y);
                    label.setAttribute('class', 'country-label');
                    label.textContent = countryName;
                    label.dataset.countryCode = countryCode;
                    labelGroup.appendChild(label);
                    
                    // [추가] 이름 겹침 방지 로직
                    const bbox = label.getBBox();
                    const padding = 5;
                    const paddedBbox = { x: bbox.x - padding, y: bbox.y - padding, width: bbox.width + padding * 2, height: bbox.height + padding * 2 };
                    let isOverlapping = false;
                    for (const placedBox of placedLabelBoxes) {
                        if (!(paddedBbox.x + paddedBbox.width < placedBox.x || placedBox.x + placedBox.width < paddedBbox.x || paddedBbox.y + paddedBbox.height < placedBox.y || placedBox.y + placedBox.height < paddedBbox.y)) {
                            isOverlapping = true;
                            break;
                        }
                    }
                    if (isOverlapping) label.remove();
                    else placedLabelBoxes.push(paddedBbox);
                }
            });

            // [추가] 호버 이벤트 리스너 추가
            countryGroup.querySelectorAll('.country').forEach(path => {
                path.addEventListener('mouseover', handleCountryHover);
                path.addEventListener('mouseout', handleCountryHover);
            });

            drawGridLines();
        }
        
        function handleCountryHover(event) {
            const code = event.target.dataset.countryCode;
            if (!code) return;
            const label = document.querySelector(`.country-label[data-country-code="${code}"]`);
            if (event.type === 'mouseover') {
                event.target.classList.add('country-hover');
                if (label) label.classList.add('label-hover');
            } else {
                event.target.classList.remove('country-hover');
                if (label) label.classList.remove('label-hover');
            }
        }
        
        const getPolygonCenter = coords => {
            let lonMin = 180, latMin = 90, lonMax = -180, latMax = -90;
            coords.forEach(p => {
                if (p[0] < lonMin) lonMin = p[0]; if (p[1] < latMin) latMin = p[1];
                if (p[0] > lonMax) lonMax = p[0]; if (p[1] > latMax) latMax = p[1];
            });
            return [(lonMin + lonMax) / 2, (latMin + latMax) / 2];
        };

        function drawGridLines() {
            const grid = document.getElementById('gridLines');
            grid.innerHTML = '';
            for (let lon = -180; lon <= 180; lon += 30) {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                let d = 'M';
                for (let lat = -85; lat <= 85; lat += 5) d += mercatorProjection(lon, lat).join(',') + 'L';
                path.setAttribute('d', d.slice(0, -1)); path.setAttribute('class', 'grid-line'); grid.appendChild(path);
            }
            for (let lat = -60; lat <= 80; lat += 30) {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                let d = 'M';
                for (let lon = -180; lon <= 180; lon += 5) d += mercatorProjection(lon, lat).join(',') + 'L';
                path.setAttribute('d', d.slice(0, -1)); path.setAttribute('class', 'grid-line'); grid.appendChild(path);
            }
        }
        
        function updateDynamicSizes() {
            const optimalFontSize = Math.max(8, Math.min(48, Math.round(mapWidth / 183)));
            document.getElementById('fontSize').value = optimalFontSize;
            updateLabelStyles();
        }
        
        function updateLabelStyles() {
            const fontSize = document.getElementById('fontSize').value;
            const strokeWidth = fontSize / 6;
            document.getElementById('fontSizeValue').textContent = fontSize + 'px';
            document.querySelectorAll('.country-label').forEach(label => {
                label.setAttribute('font-size', fontSize);
                label.setAttribute('stroke-width', strokeWidth);
            });
            const labelGroup = document.getElementById('countryLabels');
            if (labelGroup) labelGroup.style.display = document.getElementById('showLabels').checked ? '' : 'none';
        }

        document.getElementById('showLabels').addEventListener('change', updateLabelStyles);
        document.getElementById('fontSize').addEventListener('input', updateLabelStyles);
        
        document.getElementById('mapSize').addEventListener('input', function() {
            const wrapper = document.querySelector('.map-wrapper');
            const oldWidth = mapWidth;
            const centerXRatio = (wrapper.scrollLeft + wrapper.clientWidth / 2) / oldWidth;

            mapWidth = parseInt(this.value);
            mapHeight = mapWidth / 2;
            document.getElementById('mapSizeValue').textContent = `${mapWidth}x${mapHeight}px`;
            
            initMap();
            
            // [추가] 중앙 기준 크기 조절을 위한 스크롤 위치 조정
            requestAnimationFrame(() => {
                const newScrollLeft = (centerXRatio * mapWidth) - wrapper.clientWidth / 2;
                wrapper.scrollLeft = newScrollLeft;
            });
        });

        const svg = document.getElementById('worldMap');
        
        function updateTransform() {
            const transformValue = `translate(${currentX}, ${currentY}) scale(${currentScale})`;
            ['gridLines', 'countries', 'countryLabels'].forEach(id => {
                const group = document.getElementById(id);
                if (group) group.setAttribute('transform', transformValue);
            });
        }
        
        svg.addEventListener('wheel', e => {
            e.preventDefault();
            const rect = svg.getBoundingClientRect();
            const point = svg.createSVGPoint();
            point.x = e.clientX - rect.left;
            point.y = e.clientY - rect.top;
            const svgPoint = point.matrixTransform(svg.getScreenCTM().inverse());
            const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = Math.max(0.5, Math.min(50, currentScale * scaleFactor));
            currentX = svgPoint.x - (svgPoint.x - currentX) * (newScale / currentScale);
            currentY = svgPoint.y - (svgPoint.y - currentY) * (newScale / currentScale);
            currentScale = newScale;
            updateTransform();
        });

        // [수정] 스크롤 시에도 정확한 위치에서 드래그되도록 로직 변경
        svg.addEventListener('mousedown', e => { 
            isDragging = true; 
            panStart.x = currentX;
            panStart.y = currentY;
            dragStart.x = e.clientX; 
            dragStart.y = e.clientY; 
            svg.style.cursor = 'grabbing'; 
        });
        svg.addEventListener('mousemove', e => { 
            if (isDragging) { 
                const dx = e.clientX - dragStart.x;
                const dy = e.clientY - dragStart.y;
                currentX = panStart.x + dx; 
                currentY = panStart.y + dy; 
                updateTransform(); 
            }
        });
        const endDrag = () => { isDragging = false; svg.style.cursor = 'grab'; };
        svg.addEventListener('mouseup', endDrag);
        svg.addEventListener('mouseleave', endDrag);

        function downloadSVG() {
            const svgEl = document.getElementById('worldMap');
            svgEl.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            const svgData = svgEl.outerHTML;
            const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = 'world_map.svg'; a.click(); URL.revokeObjectURL(url);
        }

        function downloadPNG() {
            const svgEl = document.getElementById('worldMap');
            const canvas = document.createElement('canvas');
            canvas.width = mapWidth * 2; canvas.height = mapHeight * 2;
            const ctx = canvas.getContext('2d');
            const svgData = new XMLSerializer().serializeToString(svgEl);
            const img = new Image();
            img.onload = () => {
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                const a = document.createElement('a');
                a.href = canvas.toDataURL('image/png'); a.download = 'world_map.png'; a.click();
            };
            img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgData)));
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            const mapWrapper = document.querySelector('.map-wrapper');
            mapWidth = mapWrapper.clientWidth;
            mapHeight = mapWidth / 2;
            const mapSizeSlider = document.getElementById('mapSize');
            mapSizeSlider.value = mapWidth;
            document.getElementById('mapSizeValue').textContent = `${mapWidth}x${mapHeight}px`;
            loadWorldData();
        });
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÏÑ∏Í≥ÑÏßÄÎèÑ ÌïôÏäµ</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Noto Sans KR', sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; overflow: hidden; }
        .container { width: 100vw; height: 100vh; position: relative; display: flex; flex-direction: column; }
        .header { background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px); padding: 15px 20px; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1); display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px; z-index: 10; }
        .title { font-size: 1.5rem; font-weight: 700; color: #2c3e50; }
        .controls { display: flex; gap: 15px; align-items: center; flex-wrap: wrap; }
        .control-group { display: flex; align-items: center; gap: 8px; background: rgba(255, 255, 255, 0.7); padding: 8px 12px; border-radius: 20px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); }
        .toggle { position: relative; display: inline-block; width: 50px; height: 24px; }
        .toggle input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 24px; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #4CAF50; }
        input:checked + .slider:before { transform: translateX(26px); }
        .size-slider { width: 120px; }
        .btn { background: linear-gradient(45deg, #667eea, #764ba2); color: white; border: none; padding: 8px 16px; border-radius: 20px; cursor: pointer; font-family: 'Noto Sans KR', sans-serif; font-weight: 500; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3); }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4); }
        .map-wrapper { flex: 1; overflow: auto; position: relative; background: #b0b0b0; }
        .map-container { position: relative; background: #b0b0b0; }
        #worldMap { cursor: grab; display: block; background: #a6d9ff; }
        #worldMap:active { cursor: grabbing; }
        .loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(255, 255, 255, 0.9); padding: 20px 40px; border-radius: 10px; font-size: 1.2rem; font-weight: 500; color: #2c3e50; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2); z-index: 20; }
        .country { stroke-width: 0.5; stroke: #333; transition: all 0.1s ease-in-out; }
        .country-hover { stroke-width: 1.5; stroke: #c0392b; filter: brightness(1.1); }
        .grid-line { fill: none; stroke: #666; stroke-width: 0.2; opacity: 0.5; pointer-events: none; }
        .country-label { font-family: 'Noto Sans KR', sans-serif; text-anchor: middle; fill: #2c3e50; font-weight: 600; pointer-events: none; paint-order: stroke; stroke: white; stroke-linejoin: round; stroke-width: 1; transition: all 0.1s ease-in-out; font-size: 6px; }
        .label-hover { fill: #c0392b; }
        .country-callout { stroke: rgba(44, 62, 80, 0.6); stroke-width: 1; fill: none; pointer-events: none; }
        .zoom-control { display: flex; align-items: center; gap: 8px; }
        .zoom-btn { width: 32px; height: 32px; border-radius: 50%; border: none; background: linear-gradient(45deg, #667eea, #764ba2); color: #fff; font-size: 1.2rem; line-height: 1; cursor: pointer; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15); transition: transform 0.2s ease, box-shadow 0.2s ease; }
        .zoom-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4); }
        /* [Ï∂îÍ∞Ä] Íµ≠Í∞Ä Î™©Î°ù Ìå®ÎÑê Ïä§ÌÉÄÏùº */
        .country-list-panel { position: absolute; top: 0; right: 0; width: calc(100% / 6); height: 100%; background: rgba(255, 255, 255, 0.85); backdrop-filter: blur(5px); transform: translateX(0); transition: transform 0.3s ease-in-out; overflow-y: auto; z-index: 15; border-left: 1px solid rgba(0,0,0,0.1); }
        .country-list-panel.hidden { transform: translateX(100%); }
        .country-list-panel h3 { font-size: 1rem; padding: 15px; background: rgba(0,0,0,0.05); text-align: center; }
        .country-list-panel ul { list-style: none; padding: 10px; }
        .country-list-panel li { padding: 8px 15px; font-size: 0.9rem; border-bottom: 1px solid #eee; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="title">üåç ÏÑ∏Í≥ÑÏßÄÎèÑ ÌïôÏäµ</div>
            <div class="controls">
                <div class="control-group"><label>ÎÇòÎùº Ïù¥Î¶Ñ</label><label class="toggle"><input type="checkbox" id="showLabels" checked><span class="slider"></span></label></div>
                <div class="control-group"><label>Í∏ÄÏûê ÌÅ¨Í∏∞</label><input type="range" id="fontSize" class="size-slider" min="50" max="200" step="5" value="100"><span id="fontSizeValue">6.0px (100%)</span></div>
                <div class="control-group">
                    <label>Ï§å</label>
                    <div class="zoom-control">
                        <button type="button" class="zoom-btn" id="zoomOutBtn" aria-label="Ï∂ïÏÜå">‚àí</button>
                        <span id="zoomValue">100%</span>
                        <button type="button" class="zoom-btn" id="zoomInBtn" aria-label="ÌôïÎåÄ">+</button>
                    </div>
                </div>
                <button class="btn" id="toggleListBtn">Î™©Î°ù</button>
                <button class="btn" onclick="downloadPNG()">PNG Îã§Ïö¥Î°úÎìú</button>
                <button class="btn" onclick="downloadSVG()">SVG Îã§Ïö¥Î°úÎìú</button>
            </div>
        </div>
        <div class="map-wrapper">
            <div class="map-container" id="mapContainer">
                <div class="loading" id="loadingIndicator">ÏßÄÎèÑ Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò§Îäî Ï§ë...</div>
                <svg id="worldMap"></svg>
            </div>
            <div class="country-list-panel" id="countryListPanel">
                <h3>ÌòÑÏû¨ Î≥¥Ïù¥Îäî Íµ≠Í∞Ä</h3>
                <ul id="countryList"></ul>
            </div>
        </div>
    </div>

    <script>
        let currentScale = 1, currentX = 0, currentY = 0;
        let isDragging = false, dragStart = { x: 0, y: 0 }, panStart = { x: 0, y: 0 };
        let worldData = null;
        const BASE_MAP_WIDTH = 8000;
        const BASE_MAP_HEIGHT = 4000;
        let mapWidth = BASE_MAP_WIDTH, mapHeight = BASE_MAP_HEIGHT;
        const MAX_SCALE = 5;
        const MIN_SCALE = 0.01;
        const BASE_FONT_SIZE = 6;
        const SVG_NS = 'http://www.w3.org/2000/svg';
        const colorCache = new Map();

        const getCountryColor = (code, index) => {
            if (colorCache.has(code)) return colorCache.get(code);
            const hue = (index * 137.508) % 360;
            const color = `hsl(${hue}, 65%, 65%)`;
            colorCache.set(code, color);
            return color;
        };
        const clampLatitude = lat => {
            let clamped = Math.max(-89.9999, Math.min(89.9999, lat));
            if (clamped < -75) {
                clamped = -75 + (clamped + 75) * 0.2;
            }
            return clamped;
        };
        const countryNames = {
            "AF": "ÏïÑÌîÑÍ∞ÄÎãàÏä§ÌÉÑ",
            "AO": "ÏïôÍ≥®Îùº",
            "AL": "ÏïåÎ∞îÎãàÏïÑ",
            "AE": "ÏïÑÎûçÏóêÎØ∏Î¶¨Ìä∏",
            "AR": "ÏïÑÎ•¥Ìó®Ìã∞ÎÇò",
            "AM": "ÏïÑÎ•¥Î©îÎãàÏïÑ",
            "TF": "ÌîÑÎûëÏä§Î†π ÎÇ®Î∞© Î∞è ÎÇ®Í∑π",
            "AU": "Ìò∏Ï£º",
            "AT": "Ïò§Ïä§Ìä∏Î¶¨ÏïÑ",
            "AZ": "ÏïÑÏ†úÎ•¥Î∞îÏù¥Ïûî",
            "BI": "Î∂ÄÎ£¨Îîî",
            "BE": "Î≤®Í∏∞Ïóê",
            "BJ": "Î≤†ÎÉâ",
            "BF": "Î∂ÄÎ•¥ÌÇ§ÎÇòÌååÏÜå",
            "BD": "Î∞©Í∏ÄÎùºÎç∞Ïãú",
            "BG": "Î∂àÍ∞ÄÎ¶¨ÏïÑ",
            "BA": "Î≥¥Ïä§ÎãàÏïÑ Ìó§Î•¥Ï≤¥Í≥†ÎπÑÎÇò",
            "BY": "Î≤®ÎùºÎ£®Ïä§",
            "BZ": "Î≤®Î¶¨Ï¶à",
            "BM": "Î≤ÑÎÆ§Îã§",
            "BO": "Î≥ºÎ¶¨ÎπÑÏïÑ",
            "BR": "Î∏åÎùºÏßà",
            "BN": "Î∏åÎ£®ÎÇòÏù¥",
            "BT": "Î∂ÄÌÉÑ",
            "BW": "Î≥¥Ï∏†ÏôÄÎÇò",
            "CF": "Ï§ëÏïôÏïÑÌîÑÎ¶¨Ïπ¥ Í≥µÌôîÍµ≠",
            "CA": "Ï∫êÎÇòÎã§",
            "CH": "Ïä§ÏúÑÏä§",
            "CL": "Ïπ†Î†à",
            "CN": "Ï§ëÍµ≠",
            "CI": "ÏΩîÌä∏ÎîîÎ∂ÄÏïÑÎ•¥",
            "CM": "Ïπ¥Î©îÎ£¨",
            "CD": "ÏΩ©Í≥† ÎØºÏ£º Í≥µÌôîÍµ≠",
            "CG": "ÏΩ©Í≥† Í≥µÌôîÍµ≠",
            "CO": "ÏΩúÎ°¨ÎπÑÏïÑ",
            "CR": "ÏΩîÏä§ÌÉÄÎ¶¨Ïπ¥",
            "CU": "Ïø†Î∞î",
            "CY": "ÌÇ§ÌîÑÎ°úÏä§",
            "CZ": "Ï≤¥ÏΩî",
            "DE": "ÎèÖÏùº",
            "DJ": "ÏßÄÎ∂ÄÌã∞",
            "DK": "Îç¥ÎßàÌÅ¨",
            "DO": "ÎèÑÎØ∏ÎãàÏπ¥ Í≥µÌôîÍµ≠",
            "DZ": "ÏïåÏ†úÎ¶¨",
            "EC": "ÏóêÏΩ∞ÎèÑÎ•¥",
            "EG": "Ïù¥ÏßëÌä∏",
            "ER": "ÏóêÎ¶¨Ìä∏Î†àÏïÑ",
            "ES": "Ïä§ÌéòÏù∏",
            "EE": "ÏóêÏä§ÌÜ†ÎãàÏïÑ",
            "ET": "ÏóêÌã∞Ïò§ÌîºÏïÑ",
            "FI": "ÌïÄÎûÄÎìú",
            "FJ": "ÌîºÏßÄ",
            "GA": "Í∞ÄÎ¥â",
            "GB": "ÏòÅÍµ≠",
            "GE": "Ï°∞ÏßÄÏïÑ",
            "GH": "Í∞ÄÎÇò",
            "GN": "Í∏∞Îãà",
            "GM": "Í∞êÎπÑÏïÑ",
            "GW": "Í∏∞ÎãàÎπÑÏÇ¨Ïö∞",
            "GQ": "Ï†ÅÎèÑ Í∏∞Îãà",
            "GR": "Í∑∏Î¶¨Ïä§",
            "GL": "Í∑∏Î¶∞ÎûÄÎìú",
            "GT": "Í≥ºÌÖåÎßêÎùº",
            "GY": "Í∞ÄÏù¥ÏïÑÎÇò",
            "HN": "Ïò®ÎëêÎùºÏä§",
            "HR": "ÌÅ¨Î°úÏïÑÌã∞ÏïÑ",
            "HT": "ÏïÑÏù¥Ìã∞",
            "HU": "ÌóùÍ∞ÄÎ¶¨",
            "ID": "Ïù∏ÎèÑÎÑ§ÏãúÏïÑ",
            "IN": "Ïù∏ÎèÑ",
            "IE": "ÏïÑÏùºÎûúÎìú",
            "IR": "Ïù¥ÎûÄ",
            "IQ": "Ïù¥ÎùºÌÅ¨",
            "IS": "ÏïÑÏù¥Ïä¨ÎûÄÎìú",
            "IL": "Ïù¥Ïä§ÎùºÏóò",
            "IT": "Ïù¥ÌÉàÎ¶¨ÏïÑ",
            "JM": "ÏûêÎ©îÏù¥Ïπ¥",
            "JO": "ÏöîÎ•¥Îã®",
            "JP": "ÏùºÎ≥∏",
            "KZ": "Ïπ¥ÏûêÌùêÏä§ÌÉÑ",
            "KE": "ÏºÄÎÉê",
            "KG": "ÌÇ§Î•¥Í∏∞Ïä§Ïä§ÌÉÑ",
            "KH": "Ï∫ÑÎ≥¥ÎîîÏïÑ",
            "KR": "ÎåÄÌïúÎØºÍµ≠",
            "XK": "ÏΩîÏÜåÎ≥¥",
            "KW": "Ïø†Ïõ®Ïù¥Ìä∏",
            "LA": "ÎùºÏò§Ïä§",
            "LB": "Î†àÎ∞îÎÖº",
            "LR": "ÎùºÏù¥Î≤†Î¶¨ÏïÑ",
            "LY": "Î¶¨ÎπÑÏïÑ",
            "LK": "Ïä§Î¶¨ÎûëÏπ¥",
            "LS": "Î†àÏÜåÌÜ†",
            "LT": "Î¶¨Ìà¨ÏïÑÎãàÏïÑ",
            "LU": "Î£©ÏÖàÎ∂ÄÎ•¥ÌÅ¨",
            "LV": "ÎùºÌä∏ÎπÑÏïÑ",
            "MA": "Î™®Î°úÏΩî",
            "MD": "Î™∞ÎèÑÎ∞î",
            "MG": "ÎßàÎã§Í∞ÄÏä§Ïπ¥Î•¥",
            "MX": "Î©ïÏãúÏΩî",
            "MK": "Î∂ÅÎßàÏºÄÎèÑÎãàÏïÑ",
            "ML": "ÎßêÎ¶¨",
            "MM": "ÎØ∏ÏñÄÎßà",
            "ME": "Î™¨ÌÖåÎÑ§Í∑∏Î°ú",
            "MN": "Î™ΩÍ≥®",
            "MZ": "Î™®Ïû†ÎπÑÌÅ¨",
            "MR": "Î™®Î¶¨ÌÉÄÎãà",
            "MW": "ÎßêÎùºÏúÑ",
            "MY": "ÎßêÎ†àÏù¥ÏãúÏïÑ",
            "NA": "ÎÇòÎØ∏ÎπÑÏïÑ",
            "NC": "ÎàÑÎ≤®ÏπºÎ†àÎèÑÎãà",
            "NE": "ÎãàÏ†úÎ•¥",
            "NG": "ÎÇòÏù¥ÏßÄÎ¶¨ÏïÑ",
            "NI": "ÎãàÏπ¥ÎùºÍ≥º",
            "NL": "ÎÑ§ÎçúÎûÄÎìú",
            "NO": "ÎÖ∏Î•¥Ïõ®Ïù¥",
            "NP": "ÎÑ§Ìåî",
            "NZ": "Îâ¥ÏßàÎûúÎìú",
            "OM": "Ïò§Îßå",
            "PK": "ÌååÌÇ§Ïä§ÌÉÑ",
            "PA": "ÌååÎÇòÎßà",
            "PE": "ÌéòÎ£®",
            "PH": "ÌïÑÎ¶¨ÌïÄ",
            "PG": "ÌååÌë∏ÏïÑÎâ¥Í∏∞Îãà",
            "PL": "Ìè¥ÎûÄÎìú",
            "PR": "Ìë∏ÏóêÎ•¥ÌÜ†Î¶¨ÏΩî",
            "KP": "Ï°∞ÏÑ†ÎØºÏ£ºÏ£ºÏùòÏù∏ÎØºÍ≥µÌôîÍµ≠",
            "PT": "Ìè¨Î•¥Ìà¨Í∞à",
            "PY": "ÌååÎùºÍ≥ºÏù¥",
            "QA": "Ïπ¥ÌÉÄÎ•¥",
            "RO": "Î£®ÎßàÎãàÏïÑ",
            "RU": "Îü¨ÏãúÏïÑ",
            "RW": "Î•¥ÏôÑÎã§",
            "EH": "ÏÑúÏÇ¨ÌïòÎùº",
            "SA": "ÏÇ¨Ïö∞ÎîîÏïÑÎùºÎπÑÏïÑ",
            "SD": "ÏàòÎã®",
            "SS": "ÎÇ®ÏàòÎã®",
            "SN": "ÏÑ∏ÎÑ§Í∞à",
            "SB": "ÏÜîÎ°úÎ™¨ Ï†úÎèÑ",
            "SL": "ÏãúÏóêÎùºÎ¶¨Ïò®",
            "SV": "ÏóòÏÇ¥Î∞îÎèÑÎ•¥",
            "SO": "ÏÜåÎßêÎ¶¨ÏïÑ",
            "RS": "ÏÑ∏Î•¥ÎπÑÏïÑ",
            "SR": "ÏàòÎ¶¨ÎÇ®",
            "SK": "Ïä¨Î°úÎ∞îÌÇ§ÏïÑ",
            "SI": "Ïä¨Î°úÎ≤†ÎãàÏïÑ",
            "SE": "Ïä§Ïõ®Îç¥",
            "SZ": "ÏóêÏä§ÏôÄÌã∞Îãà",
            "SY": "ÏãúÎ¶¨ÏïÑ",
            "TD": "Ï∞®Îìú",
            "TG": "ÌÜ†Í≥†",
            "TH": "ÌÉúÍµ≠",
            "TJ": "ÌÉÄÏßÄÌÇ§Ïä§ÌÉÑ",
            "TM": "Ìà¨Î•¥ÌÅ¨Î©îÎãàÏä§ÌÉÑ",
            "TL": "ÎèôÌã∞Î™®Î•¥",
            "TT": "Ìä∏Î¶¨ÎãàÎã§Îìú ÌÜ†Î∞îÍ≥†",
            "TN": "ÌäÄÎãàÏßÄ",
            "TR": "ÌäÄÎ•¥ÌÇ§Ïòà",
            "TW": "ÎåÄÎßå",
            "TZ": "ÌÉÑÏûêÎãàÏïÑ",
            "UG": "Ïö∞Í∞ÑÎã§",
            "UA": "Ïö∞ÌÅ¨ÎùºÏù¥ÎÇò",
            "UY": "Ïö∞Î£®Í≥ºÏù¥",
            "US": "ÎØ∏Íµ≠",
            "UZ": "Ïö∞Ï¶àÎ≤†ÌÇ§Ïä§ÌÉÑ",
            "VE": "Î≤†ÎÑ§ÏàòÏóòÎùº",
            "VN": "Î≤†Ìä∏ÎÇ®",
            "VU": "Î∞îÎàÑÏïÑÌà¨",
            "PS": "ÌåîÎ†àÏä§ÌÉÄÏù∏",
            "YE": "ÏòàÎ©ò",
            "ZA": "ÎÇ®ÏïÑÌîÑÎ¶¨Ïπ¥ Í≥µÌôîÍµ≠",
            "ZM": "Ïû†ÎπÑÏïÑ",
            "ZW": "ÏßêÎ∞îÎ∏åÏõ®",
            "AW": "ÏïÑÎ£®Î∞î",
            "AI": "ÏïµÍ∑àÎùº",
            "AS": "ÏïÑÎ©îÎ¶¨Ïπ∏ÏÇ¨Î™®ÏïÑ",
            "AG": "Ïï§Ìã∞Í∞Ä Î∞îÎ∂ÄÎã§",
            "BH": "Î∞îÎ†àÏù∏",
            "BB": "Î∞îÎ≤†Ïù¥ÎèÑÏä§",
            "BL": "ÏÉùÎ∞îÎ•¥ÌÖîÎ†àÎØ∏",
            "BS": "Î∞îÌïòÎßà",
            "IO": "ÏòÅÍµ≠Î†π Ïù∏ÎèÑÏñë ÏßÄÏó≠",
            "KY": "ÏºÄÏù¥Îß® Ï†úÎèÑ",
            "KM": "ÏΩîÎ™®Î°ú",
            "CV": "Ïπ¥Î≥¥Î≤†Î•¥Îç∞",
            "CK": "Ïø° Ï†úÎèÑ",
            "CW": "ÌÄ¥ÎùºÏÜå",
            "DM": "ÎèÑÎØ∏ÎãàÏπ¥ Ïó∞Î∞©",
            "FK": "Ìè¨ÌÅ¥ÎûúÎìú Ï†úÎèÑ",
            "FO": "ÌéòÎ°ú Ï†úÎèÑ",
            "FM": "ÎØ∏ÌÅ¨Î°úÎÑ§ÏãúÏïÑ Ïó∞Î∞©",
            "GD": "Í∑∏Î†àÎÇòÎã§",
            "GU": "Í¥å",
            "GG": "Í±¥ÏßÄ",
            "HK": "ÌôçÏΩ©",
            "IM": "Îß®ÏÑ¨",
            "JE": "Ï†ÄÏßÄ",
            "KI": "ÌÇ§Î¶¨Î∞îÏãú",
            "KN": "ÏÑ∏Ïù∏Ìä∏ÌÇ§Ï∏† ÎÑ§ÎπÑÏä§",
            "LC": "ÏÑ∏Ïù∏Ìä∏Î£®ÏãúÏïÑ",
            "LI": "Î¶¨ÌûàÌÖêÏäàÌÉÄÏù∏",
            "MO": "ÎßàÏπ¥Ïò§",
            "MF": "ÏÉùÎßàÎ•¥ÌÉ±",
            "MV": "Î™∞ÎîîÎ∏å",
            "MS": "Î™¨Ìä∏ÏÑ∏Îû´",
            "MU": "Î™®Î¶¨ÏÖîÏä§",
            "MP": "Î∂ÅÎßàÎ¶¨ÏïÑÎÇò Ï†úÎèÑ",
            "MT": "Î™∞ÌÉÄ",
            "NU": "ÎãàÏö∞Ïóê",
            "NR": "ÎÇòÏö∞Î£®",
            "PN": "ÌïèÏºÄÏñ∏ Ï†úÎèÑ",
            "PW": "ÌåîÎùºÏö∞",
            "SM": "ÏÇ∞ÎßàÎ¶¨ÎÖ∏",
            "ST": "ÏÉÅÌà¨Î©î ÌîÑÎ¶∞ÏãúÌéò",
            "SC": "ÏÑ∏Ïù¥ÏÖ∏",
            "SG": "Ïã±Í∞ÄÌè¨Î•¥",
            "SH": "ÏÑ∏Ïù∏Ìä∏Ìó¨Î†àÎÇò",
            "SX": "Ïã†Ìä∏ÎßàÎ•¥ÌÑ¥",
            "TC": "ÌÑ∞ÌÅ¨Ïä§ ÏºÄÏù¥Ïª§Ïä§ Ï†úÎèÑ",
            "TO": "ÌÜµÍ∞Ä",
            "TV": "Ìà¨Î∞úÎ£®",
            "VC": "ÏÑ∏Ïù∏Ìä∏ÎπàÏÑºÌä∏ Í∑∏Î†àÎÇòÎîò",
            "VG": "ÏòÅÍµ≠Î†π Î≤ÑÏßÑÏïÑÏùºÎûúÎìú",
            "VI": "ÎØ∏Íµ≠Î†π Î≤ÑÏßÑÏïÑÏùºÎûúÎìú",
            "WS": "ÏÇ¨Î™®ÏïÑ",
            "GS": "ÏÇ¨Ïö∞Ïä§Ï°∞ÏßÄÏïÑ ÏÇ¨Ïö∞Ïä§ÏÉåÎìúÏúÑÏπò Ï†úÎèÑ"
        };


        const mercatorProjection = (lon, lat) => {
            const adjustedLat = clampLatitude(lat);
            return [
                (lon + 180) * (mapWidth / 360),
                (mapHeight / 2) - (mapWidth / (2 * Math.PI)) * Math.log(Math.tan(Math.PI / 4 + adjustedLat * Math.PI / 360))
            ];
        };
        const geoJsonToSvgPath = (coordinates, type) => {
            let path = '';
            if (type === 'Polygon') path = coordinates.map(ring => 'M' + ring.map(p => mercatorProjection(p[0], p[1]).join(',')).join('L') + 'Z').join('');
            else if (type === 'MultiPolygon') path = coordinates.map(polygon => polygon.map(ring => 'M' + ring.map(p => mercatorProjection(p[0], p[1]).join(',')).join('L') + 'Z').join('')).join('');
            return path;
        };
        const getPolygonArea = coords => {
            let area = 0;
            for (let i = 0; i < coords.length; i++) {
                const [x1, y1] = mercatorProjection(coords[i][0], coords[i][1]);
                const [x2, y2] = mercatorProjection(coords[(i + 1) % coords.length][0], coords[(i + 1) % coords.length][1]);
                area += x1 * y2 - x2 * y1;
            }
            return Math.abs(area / 2);
        };

        async function fetchWithFallback(urls) {
            let lastError = null;
            for (const url of urls) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    return response;
                } catch (error) {
                    lastError = error;
                    console.warn(`Failed to load map data from ${url}:`, error);
                }
            }
            throw lastError ?? new Error('Unknown error while loading map data');
        }

        async function loadWorldData() {
            const loadingIndicator = document.getElementById('loadingIndicator');
            try {
                const response = await fetchWithFallback([
                    'ne_50m_admin_0_countries.json',
                    'https://tb.tues.myds.me/ne_50m_admin_0_countries.json'
                ]);
                worldData = await response.json();
                worldData.features.forEach(f => {
                    if (!f.geometry) return;
                    const largestPart = f.geometry.type === 'Polygon' ? f.geometry.coordinates[0] : f.geometry.coordinates.reduce((a, b) => a.flat().length > b.flat().length ? a : b, [])[0];
                    f.properties.calculatedArea = largestPart ? getPolygonArea(largestPart) : 0;
                });
                worldData.features.sort((a, b) => b.properties.calculatedArea - a.properties.calculatedArea);
                loadingIndicator.style.display = 'none';
                initMap();
            } catch (error) {
                console.error('Failed to load world map data:', error);
                loadingIndicator.textContent = 'ÏßÄÎèÑ Îç∞Ïù¥ÌÑ∞ Î°úÎìúÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.';
            }
        }
        
        function initMap() {
            const svg = document.getElementById('worldMap');
            const mapContainer = document.getElementById('mapContainer');
            svg.setAttribute('width', mapWidth); svg.setAttribute('height', mapHeight);
            svg.setAttribute('viewBox', `0 0 ${mapWidth} ${mapHeight}`);
            mapContainer.style.width = mapWidth + 'px'; mapContainer.style.height = mapHeight + 'px';
            svg.innerHTML = `<g id="gridLines"></g><g id="countries"></g><g id="labelConnectors"></g><g id="countryLabels"></g>`;
            drawMap();
            updateDynamicSizes(); // [ÏàòÏ†ï] ÏµúÏ¥à Î°úÎìú ÏãúÏóêÎßå Í∏ÄÏûê ÌÅ¨Í∏∞ ÏûêÎèô Ï°∞Ï†à
            updateCountryList(); // [Ï∂îÍ∞Ä] Ï¥àÍ∏∞ Íµ≠Í∞Ä Î™©Î°ù ÏóÖÎç∞Ïù¥Ìä∏
            updateZoomDisplay();
        }

        function drawMap() {
            if (!worldData) return;
            const countryGroup = document.getElementById('countries');
            const labelGroup = document.getElementById('countryLabels');

            worldData.features.forEach((feature, index) => {
                const { properties, geometry } = feature;
                if (!geometry || properties.ISO_A2 === '-99') return;
                const countryCode = properties.ISO_A2;
                const countryName = countryNames[countryCode] || properties.ADMIN;

                const path = document.createElementNS(SVG_NS, 'path');
                path.setAttribute('d', geoJsonToSvgPath(geometry.coordinates, geometry.type));
                path.setAttribute('class', 'country');
                path.setAttribute('fill', getCountryColor(countryCode, index));
                path.dataset.countryCode = countryCode;
                countryGroup.appendChild(path);

                if (countryName) {
                    const label = document.createElementNS(SVG_NS, 'text');
                    label.setAttribute('class', 'country-label'); label.textContent = countryName; label.dataset.countryCode = countryCode;
                    labelGroup.appendChild(label);

                    const largestPolygon = geometry.type === 'Polygon'
                        ? geometry.coordinates
                        : geometry.coordinates.reduce((largest, polygon) => {
                            const largestLength = largest?.[0]?.length || 0;
                            const polygonLength = polygon?.[0]?.length || 0;
                            return polygonLength > largestLength ? polygon : largest;
                        }, geometry.coordinates[0]);
                    const largestPartCoords = largestPolygon[0] || [];
                    const centerLonLat = getPolygonCenter(largestPartCoords);
                    const [cx, cy] = mercatorProjection(centerLonLat[0], centerLonLat[1]);
                    label.setAttribute('x', cx);
                    label.setAttribute('y', cy);
                    label.dataset.anchorX = cx;
                    label.dataset.anchorY = cy;
                    label.dataset.area = properties.calculatedArea ?? 0;
                }
            });

            countryGroup.querySelectorAll('.country').forEach(path => { path.addEventListener('mouseover', handleCountryHover); path.addEventListener('mouseout', handleCountryHover); });
            drawGridLines();
        }
        
        function handleCountryHover(event) {
            const code = event.target.dataset.countryCode; if (!code) return;
            const label = document.querySelector(`.country-label[data-country-code="${code}"]`);
            if (event.type === 'mouseover') { event.target.classList.add('country-hover'); if (label) label.classList.add('label-hover'); } 
            else { event.target.classList.remove('country-hover'); if (label) label.classList.remove('label-hover'); }
        }
        
        const getPolygonCenter = coords => {
            let lonMin = 180, latMin = 90, lonMax = -180, latMax = -90;
            coords.forEach(p => {
                if (p[0] < lonMin) lonMin = p[0]; if (p[1] < latMin) latMin = p[1];
                if (p[0] > lonMax) lonMax = p[0]; if (p[1] > latMax) latMax = p[1];
            });
            return [(lonMin + lonMax) / 2, (latMin + latMax) / 2];
        };

        function drawGridLines() {
            const grid = document.getElementById('gridLines'); grid.innerHTML = '';
            for (let lon = -180; lon <= 180; lon += 30) {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path'); let d = 'M';
                for (let lat = -85; lat <= 85; lat += 5) d += mercatorProjection(lon, lat).join(',') + 'L';
                path.setAttribute('d', d.slice(0, -1)); path.setAttribute('class', 'grid-line'); grid.appendChild(path);
            }
            for (let lat = -60; lat <= 80; lat += 30) {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path'); let d = 'M';
                for (let lon = -180; lon <= 180; lon += 5) d += mercatorProjection(lon, lat).join(',') + 'L';
                path.setAttribute('d', d.slice(0, -1)); path.setAttribute('class', 'grid-line'); grid.appendChild(path);
            }
        }
        
        function updateDynamicSizes() {
            const fontSlider = document.getElementById('fontSize');
            if (fontSlider) {
                fontSlider.value = '100';
            }
            updateLabelStyles();
        }

        function updateLabelStyles() {
            const slider = document.getElementById('fontSize');
            if (!slider) return;
            const percent = Number(slider.value);
            const fontSize = +(BASE_FONT_SIZE * percent / 100).toFixed(2);
            const labelValue = document.getElementById('fontSizeValue');
            if (labelValue) {
                labelValue.textContent = `${fontSize.toFixed(1)}px (${percent}%)`;
            }
            document.querySelectorAll('.country-label').forEach(label => {
                label.setAttribute('font-size', fontSize);
                label.setAttribute('stroke-width', 1);
            });

            const showLabels = document.getElementById('showLabels').checked;
            const labelGroup = document.getElementById('countryLabels');
            const connectorGroup = document.getElementById('labelConnectors');

            if (!showLabels) {
                if (labelGroup) labelGroup.style.display = 'none';
                if (connectorGroup) connectorGroup.style.display = 'none';
                return;
            }

            if (labelGroup) labelGroup.style.display = '';
            if (connectorGroup) connectorGroup.style.display = '';

            requestAnimationFrame(() => {
                resolveLabelCollisions();
            });
        }

        const isOverlapping = (a, b, padding = 2) => {
            return a.x < b.x + b.width + padding &&
                a.x + a.width + padding > b.x &&
                a.y < b.y + b.height + padding &&
                a.y + a.height + padding > b.y;
        };

        function resolveLabelCollisions() {
            const labelGroup = document.getElementById('countryLabels');
            const connectorGroup = document.getElementById('labelConnectors');

            if (!labelGroup || !connectorGroup) return;

            connectorGroup.innerHTML = '';
            const labels = Array.from(labelGroup.querySelectorAll('.country-label'))
                .filter(label => label.textContent?.trim().length)
                .sort((a, b) => (parseFloat(b.dataset.area || '0')) - (parseFloat(a.dataset.area || '0')));

            const placed = [];
            labels.forEach(label => {
                const anchorX = parseFloat(label.dataset.anchorX);
                const anchorY = parseFloat(label.dataset.anchorY);
                if (Number.isNaN(anchorX) || Number.isNaN(anchorY)) return;

                let targetX = anchorX;
                let targetY = anchorY;
                label.setAttribute('x', targetX);
                label.setAttribute('y', targetY);

                let bbox = label.getBBox();
                let moved = false;

                if (placed.some(p => isOverlapping(bbox, p.bbox))) {
                    const directions = [
                        { dx: 1, dy: 1 },
                        { dx: -1, dy: -1 }
                    ];
                    const step = 24;
                    const maxRadius = 960;
                    let bestPlacement = null;

                    directions.forEach(direction => {
                        label.setAttribute('x', anchorX);
                        label.setAttribute('y', anchorY);
                        let radius = step;

                        while (radius <= maxRadius) {
                            const candidateX = anchorX + direction.dx * radius;
                            const candidateY = anchorY + direction.dy * radius;
                            label.setAttribute('x', candidateX);
                            label.setAttribute('y', candidateY);
                            const candidateBBox = label.getBBox();

                            if (!placed.some(p => isOverlapping(candidateBBox, p.bbox))) {
                                if (!bestPlacement || radius < bestPlacement.radius) {
                                    bestPlacement = { x: candidateX, y: candidateY, bbox: candidateBBox, radius };
                                }
                                break;
                            }

                            radius += step;
                        }
                    });

                    if (bestPlacement) {
                        targetX = bestPlacement.x;
                        targetY = bestPlacement.y;
                        bbox = bestPlacement.bbox;
                        moved = true;
                    } else {
                        label.setAttribute('x', anchorX);
                        label.setAttribute('y', anchorY);
                        bbox = label.getBBox();
                    }
                }

                label.setAttribute('x', targetX);
                label.setAttribute('y', targetY);
                bbox = label.getBBox();
                placed.push({ bbox });

                if (moved) {
                    const callout = document.createElementNS(SVG_NS, 'line');
                    callout.setAttribute('class', 'country-callout');
                    callout.setAttribute('x1', anchorX);
                    callout.setAttribute('y1', anchorY);
                    callout.setAttribute('x2', targetX);
                    callout.setAttribute('y2', targetY);
                    connectorGroup.appendChild(callout);
                }
            });

            requestAnimationFrame(updateCountryList);
        }

        function updateZoomDisplay() {
            const zoomValue = document.getElementById('zoomValue');
            if (zoomValue) {
                zoomValue.textContent = `${(currentScale * 100).toFixed(0)}%`;
            }
        }

        function updateCountryList() {
            const listUl = document.getElementById('countryList');
            if (!listUl || !svg) return;
            if (!document.getElementById('showLabels').checked) {
                listUl.innerHTML = '';
                return;
            }
            const svgRect = svg.getBoundingClientRect();

            const visibleCountries = new Set();

            document.querySelectorAll('.country-label').forEach(label => {
                const labelRect = label.getBoundingClientRect();
                // Î†àÏù¥Î∏îÏù¥ SVG Î∑∞Ìè¨Ìä∏ ÏïàÏóê Îì§Ïñ¥Ïò§ÎäîÏßÄ ÌôïÏù∏
                if (labelRect.right > svgRect.left && labelRect.left < svgRect.right &&
                    labelRect.bottom > svgRect.top && labelRect.top < svgRect.bottom) {
                    visibleCountries.add(label.textContent);
                }
            });
            
            listUl.innerHTML = '';
            Array.from(visibleCountries).sort((a, b) => a.localeCompare(b, 'ko')).forEach(name => {
                const li = document.createElement('li');
                li.textContent = name;
                listUl.appendChild(li);
            });
        }

        document.getElementById('showLabels').addEventListener('change', updateLabelStyles);
        document.getElementById('fontSize').addEventListener('input', updateLabelStyles);
        
        document.getElementById('toggleListBtn').addEventListener('click', () => {
            const panel = document.getElementById('countryListPanel');
            panel.classList.toggle('hidden');
            if (!panel.classList.contains('hidden')) {
                updateCountryList(); // Î™©Î°ùÏù¥ Ïó¥Î¶¥ Îïå ÏóÖÎç∞Ïù¥Ìä∏
            }
        });

        const svg = document.getElementById('worldMap');

        const getViewportCenterPoint = () => {
            const rect = svg.getBoundingClientRect();
            const point = svg.createSVGPoint();
            point.x = rect.width / 2;
            point.y = rect.height / 2;
            const ctm = svg.getScreenCTM();
            return ctm ? point.matrixTransform(ctm.inverse()) : { x: mapWidth / 2, y: mapHeight / 2 };
        };

        document.getElementById('zoomInBtn').addEventListener('click', () => {
            const centerPoint = getViewportCenterPoint();
            applyZoom(currentScale * 1.05, centerPoint);
        });

        document.getElementById('zoomOutBtn').addEventListener('click', () => {
            const centerPoint = getViewportCenterPoint();
            applyZoom(currentScale / 1.05, centerPoint);
        });

        const updateTransform = () => {
            ['gridLines', 'countries', 'labelConnectors', 'countryLabels'].forEach(id => document.getElementById(id)?.setAttribute('transform', `translate(${currentX}, ${currentY}) scale(${currentScale})`));
            updateZoomDisplay();
            requestAnimationFrame(updateCountryList); // [Ï∂îÍ∞Ä] Î≥ÄÌôò ÌõÑ Íµ≠Í∞Ä Î™©Î°ù ÏóÖÎç∞Ïù¥Ìä∏
        };

        const applyZoom = (targetScale, focusPoint) => {
            const focus = focusPoint || { x: mapWidth / 2, y: mapHeight / 2 };
            const clampedScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, targetScale));
            const scaleRatio = clampedScale / currentScale;
            currentX = focus.x - (focus.x - currentX) * scaleRatio;
            currentY = focus.y - (focus.y - currentY) * scaleRatio;
            currentScale = clampedScale;
            updateTransform();
        };

        svg.addEventListener('wheel', e => {
            e.preventDefault();
            const rect = svg.getBoundingClientRect();
            const point = svg.createSVGPoint();
            point.x = e.clientX - rect.left; point.y = e.clientY - rect.top;

            // ÌòÑÏû¨ SVG Ï¢åÌëúÍ≥ÑÏóêÏÑúÏùò ÎßàÏö∞Ïä§ ÏúÑÏπò Í≥ÑÏÇ∞
            const svgPoint = point.matrixTransform(svg.getScreenCTM().inverse());

            const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = currentScale * scaleFactor;
            applyZoom(newScale, svgPoint);
        });

        svg.addEventListener('mousedown', e => { isDragging = true; panStart.x = currentX; panStart.y = currentY; dragStart.x = e.clientX; dragStart.y = e.clientY; svg.style.cursor = 'grabbing'; });
        svg.addEventListener('mousemove', e => { if (isDragging) { const dx = e.clientX - dragStart.x; const dy = e.clientY - dragStart.y; currentX = panStart.x + dx; currentY = panStart.y + dy; updateTransform(); } });
        const endDrag = () => { isDragging = false; svg.style.cursor = 'grab'; updateCountryList(); }; // [Ï∂îÍ∞Ä] ÎìúÎûòÍ∑∏ Ï¢ÖÎ£å ÌõÑ Íµ≠Í∞Ä Î™©Î°ù ÏóÖÎç∞Ïù¥Ìä∏
        svg.addEventListener('mouseup', endDrag);
        svg.addEventListener('mouseleave', endDrag);

        const download = (url, filename) => { const a = document.createElement('a'); a.href = url; a.download = filename; a.click(); URL.revokeObjectURL(url); };
        function downloadSVG() {
            const svgEl = document.getElementById('worldMap');
            svgEl.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            const svgData = svgEl.outerHTML;
            const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
            download(URL.createObjectURL(blob), 'world_map.svg');
        }
        function downloadPNG() {
            const svgEl = document.getElementById('worldMap');
            const canvas = document.createElement('canvas');
            canvas.width = mapWidth * 2; canvas.height = mapHeight * 2;
            const ctx = canvas.getContext('2d');
            const svgData = new XMLSerializer().serializeToString(svgEl);
            const img = new Image();
            img.onload = () => { ctx.drawImage(img, 0, 0, canvas.width, canvas.height); download(canvas.toDataURL('image/png'), 'world_map.png'); };
            img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgData)));
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            mapWidth = BASE_MAP_WIDTH;
            mapHeight = BASE_MAP_HEIGHT;
            loadWorldData();
        });
    </script>
</body>
</html>

 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/index.html b/index.html
index ec034678c60064f6c69986acfb92440677c13206..7f5948a1d456dfca9bb65a09ccf7e3420faf58f4 100644
--- a/index.html
+++ b/index.html
@@ -10,90 +10,118 @@
         body { font-family: 'Noto Sans KR', sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; overflow: hidden; }
         .container { width: 100vw; height: 100vh; position: relative; display: flex; flex-direction: column; }
         .header { background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px); padding: 15px 20px; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1); display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px; z-index: 10; }
         .title { font-size: 1.5rem; font-weight: 700; color: #2c3e50; }
         .controls { display: flex; gap: 15px; align-items: center; flex-wrap: wrap; }
         .control-group { display: flex; align-items: center; gap: 8px; background: rgba(255, 255, 255, 0.7); padding: 8px 12px; border-radius: 20px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); }
         .toggle { position: relative; display: inline-block; width: 50px; height: 24px; }
         .toggle input { opacity: 0; width: 0; height: 0; }
         .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 24px; }
         .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
         input:checked + .slider { background-color: #4CAF50; }
         input:checked + .slider:before { transform: translateX(26px); }
         .size-slider { width: 120px; }
         .btn { background: linear-gradient(45deg, #667eea, #764ba2); color: white; border: none; padding: 8px 16px; border-radius: 20px; cursor: pointer; font-family: 'Noto Sans KR', sans-serif; font-weight: 500; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3); }
         .btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4); }
         .map-wrapper { flex: 1; overflow: auto; position: relative; }
         .map-container { position: relative; background: linear-gradient(to bottom, #87CEEB 0%, #98D4EA 50%, #87CEEB 100%); }
         #worldMap { cursor: grab; display: block; }
         #worldMap:active { cursor: grabbing; }
         .loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(255, 255, 255, 0.9); padding: 20px 40px; border-radius: 10px; font-size: 1.2rem; font-weight: 500; color: #2c3e50; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2); z-index: 20; }
         .country { stroke-width: 0.5; stroke: #333; transition: all 0.1s ease-in-out; }
         .country-hover { stroke-width: 1.5; stroke: #c0392b; filter: brightness(1.1); }
         .grid-line { fill: none; stroke: #666; stroke-width: 0.2; opacity: 0.5; pointer-events: none; }
         .country-label { font-family: 'Noto Sans KR', sans-serif; text-anchor: middle; fill: #2c3e50; font-weight: 600; pointer-events: none; paint-order: stroke; stroke: white; stroke-linejoin: round; transition: all 0.1s ease-in-out; }
         .label-hover { fill: #c0392b; }
-        .leader-line { stroke: black; stroke-width: 1; fill: none; }
-        .leader-dot { fill: black; }
+        .zoom-control { display: flex; align-items: center; gap: 8px; }
+        .zoom-btn { width: 32px; height: 32px; border-radius: 50%; border: none; background: linear-gradient(45deg, #667eea, #764ba2); color: #fff; font-size: 1.2rem; line-height: 1; cursor: pointer; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15); transition: transform 0.2s ease, box-shadow 0.2s ease; }
+        .zoom-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4); }
+        .zoom-input-wrapper { display: flex; align-items: center; gap: 4px; background: rgba(255, 255, 255, 0.8); padding: 4px 8px; border-radius: 16px; box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1); }
+        .zoom-input { width: 60px; border: none; background: transparent; font-family: 'Noto Sans KR', sans-serif; font-weight: 600; font-size: 0.95rem; text-align: right; color: #2c3e50; outline: none; }
+        .zoom-input::-webkit-outer-spin-button, .zoom-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
+        .zoom-input[type=number] { -moz-appearance: textfield; }
+        .zoom-input-suffix { font-size: 0.85rem; font-weight: 600; color: #2c3e50; }
+        .zoom-reset-btn { border: none; padding: 6px 14px; border-radius: 16px; background: linear-gradient(45deg, #43cea2, #185a9d); color: #fff; font-family: 'Noto Sans KR', sans-serif; font-weight: 600; cursor: pointer; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15); transition: transform 0.2s ease, box-shadow 0.2s ease; }
+        .zoom-reset-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 15px rgba(67, 206, 162, 0.4); }
         /* [추가] 국가 목록 패널 스타일 */
         .country-list-panel { position: absolute; top: 0; right: 0; width: calc(100% / 6); height: 100%; background: rgba(255, 255, 255, 0.85); backdrop-filter: blur(5px); transform: translateX(0); transition: transform 0.3s ease-in-out; overflow-y: auto; z-index: 15; border-left: 1px solid rgba(0,0,0,0.1); }
         .country-list-panel.hidden { transform: translateX(100%); }
         .country-list-panel h3 { font-size: 1rem; padding: 15px; background: rgba(0,0,0,0.05); text-align: center; }
         .country-list-panel ul { list-style: none; padding: 10px; }
         .country-list-panel li { padding: 8px 15px; font-size: 0.9rem; border-bottom: 1px solid #eee; }
     </style>
 </head>
 <body>
     <div class="container">
         <div class="header">
             <div class="title">🌍 세계지도 학습</div>
             <div class="controls">
                 <div class="control-group"><label>나라 이름</label><label class="toggle"><input type="checkbox" id="showLabels" checked><span class="slider"></span></label></div>
                 <div class="control-group"><label>글자 크기</label><input type="range" id="fontSize" class="size-slider" min="8" max="48" value="9"><span id="fontSizeValue">9px</span></div>
-                <div class="control-group"><label>지도 크기</label><input type="range" id="mapSize" class="size-slider" min="1200" max="6000" value="1200" step="100"><span id="mapSizeValue">1200x600px</span></div>
+                <div class="control-group">
+                    <label>줌</label>
+                    <div class="zoom-control">
+                        <button type="button" class="zoom-btn" id="zoomOutBtn" aria-label="축소">−</button>
+                        <div class="zoom-input-wrapper">
+                            <input type="number" id="zoomInput" class="zoom-input" value="100" step="5" max="500" aria-label="줌 비율 직접 입력">
+                            <span class="zoom-input-suffix">%</span>
+                        </div>
+                        <button type="button" class="zoom-reset-btn" id="zoomResetBtn" aria-label="줌 100퍼센트로 초기화">100%</button>
+                        <span id="zoomValue">100%</span>
+                        <button type="button" class="zoom-btn" id="zoomInBtn" aria-label="확대">+</button>
+                    </div>
+                </div>
                 <button class="btn" id="toggleListBtn">목록</button>
                 <button class="btn" onclick="downloadPNG()">PNG 다운로드</button>
                 <button class="btn" onclick="downloadSVG()">SVG 다운로드</button>
             </div>
         </div>
         <div class="map-wrapper">
             <div class="map-container" id="mapContainer">
                 <div class="loading" id="loadingIndicator">지도 데이터를 불러오는 중...</div>
                 <svg id="worldMap"></svg>
             </div>
             <div class="country-list-panel" id="countryListPanel">
                 <h3>현재 보이는 국가</h3>
                 <ul id="countryList"></ul>
             </div>
         </div>
     </div>
 
     <script>
         let currentScale = 1, currentX = 0, currentY = 0;
         let isDragging = false, dragStart = { x: 0, y: 0 }, panStart = { x: 0, y: 0 };
         let worldData = null;
-        let mapWidth = 1200, mapHeight = 600;
+        let labelUpdatePending = false;
+        const BASE_MAP_WIDTH = 3840;
+        const BASE_MAP_HEIGHT = 1920;
+        let mapWidth = BASE_MAP_WIDTH, mapHeight = BASE_MAP_HEIGHT;
+        const MAX_SCALE = 5;
+        const MIN_SCALE = 0.001;
+        const svg = document.getElementById('worldMap');
+        const zoomInput = document.getElementById('zoomInput');
+        const zoomResetBtn = document.getElementById('zoomResetBtn');
 
         const pastelColors = [ '#FFB3BA', '#FFDFBA', '#FFFFBA', '#BAFFC9', '#BAE1FF', '#E0BBE4', '#FFC3A0', '#B5EAD7', '#C7CEEA', '#FFDAB9' ];
         const countryNames = {
             "AF": "아프가니스탄",
             "AO": "앙골라",
             "AL": "알바니아",
             "AE": "아랍에미리트",
             "AR": "아르헨티나",
             "AM": "아르메니아",
             "TF": "프랑스령 남방 및 남극",
             "AU": "호주",
             "AT": "오스트리아",
             "AZ": "아제르바이잔",
             "BI": "부룬디",
             "BE": "벨기에",
             "BJ": "베냉",
             "BF": "부르키나파소",
             "BD": "방글라데시",
             "BG": "불가리아",
             "BA": "보스니아 헤르체고비나",
             "BY": "벨라루스",
             "BZ": "벨리즈",
             "BM": "버뮤다",
             "BO": "볼리비아",
             "BR": "브라질",
@@ -301,309 +329,350 @@
             "WS": "사모아",
             "GS": "사우스조지아 사우스샌드위치 제도"
         };
 
 
         const mercatorProjection = (lon, lat) => [(lon + 180) * (mapWidth / 360), (mapHeight / 2) - (mapWidth / (2 * Math.PI)) * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))];
         const geoJsonToSvgPath = (coordinates, type) => {
             let path = '';
             if (type === 'Polygon') path = coordinates.map(ring => 'M' + ring.map(p => mercatorProjection(p[0], p[1]).join(',')).join('L') + 'Z').join('');
             else if (type === 'MultiPolygon') path = coordinates.map(polygon => polygon.map(ring => 'M' + ring.map(p => mercatorProjection(p[0], p[1]).join(',')).join('L') + 'Z').join('')).join('');
             return path;
         };
         const getPolygonArea = coords => {
             let area = 0;
             for (let i = 0; i < coords.length; i++) {
                 const [x1, y1] = mercatorProjection(coords[i][0], coords[i][1]);
                 const [x2, y2] = mercatorProjection(coords[(i + 1) % coords.length][0], coords[(i + 1) % coords.length][1]);
                 area += x1 * y2 - x2 * y1;
             }
             return Math.abs(area / 2);
         };
 
         async function loadWorldData() {
             const loadingIndicator = document.getElementById('loadingIndicator');
             try {
-                const response = await fetch('https://raw.githubusercontent.com/martynafford/natural-earth-geojson/refs/heads/master/50m/cultural/ne_50m_admin_0_countries.json');
+                const response = await fetch('ne_50m_admin_0_countries.json');
                 if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                 worldData = await response.json();
                 worldData.features.forEach(f => {
                     if (!f.geometry) return;
                     const largestPart = f.geometry.type === 'Polygon' ? f.geometry.coordinates[0] : f.geometry.coordinates.reduce((a, b) => a.flat().length > b.flat().length ? a : b, [])[0];
                     f.properties.calculatedArea = largestPart ? getPolygonArea(largestPart) : 0;
                 });
                 worldData.features.sort((a, b) => b.properties.calculatedArea - a.properties.calculatedArea);
                 loadingIndicator.style.display = 'none';
                 initMap();
             } catch (error) { loadingIndicator.textContent = '지도 데이터 로드에 실패했습니다.'; }
         }
         
         function initMap() {
             const svg = document.getElementById('worldMap');
             const mapContainer = document.getElementById('mapContainer');
             svg.setAttribute('width', mapWidth); svg.setAttribute('height', mapHeight);
             svg.setAttribute('viewBox', `0 0 ${mapWidth} ${mapHeight}`);
             mapContainer.style.width = mapWidth + 'px'; mapContainer.style.height = mapHeight + 'px';
             svg.innerHTML = `<g id="gridLines"></g><g id="countries"></g><g id="countryLabels"></g>`;
             drawMap();
             updateDynamicSizes(); // [수정] 최초 로드 시에만 글자 크기 자동 조절
-            updateCountryList(); // [추가] 초기 국가 목록 업데이트
+            scheduleLabelAndListUpdate(); // [추가] 초기 국가 목록 및 라벨 표시 업데이트
+            updateZoomDisplay();
         }
 
-        const isOverlapping = (box1, box2) => !(box1.x + box1.width < box2.x || box2.x + box2.width < box1.x || box1.y + box1.height < box2.y || box2.y + box2.height < box1.y);
-        const pointInPolygon = (point, vs) => {
-            const [x, y] = point; let inside = false;
-            for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
-                const [xi, yi] = vs[i]; const [xj, yj] = vs[j];
-                if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) inside = !inside;
-            }
-            return inside;
-        };
-
         function drawMap() {
             if (!worldData) return;
             const countryGroup = document.getElementById('countries');
             const labelGroup = document.getElementById('countryLabels');
-            const placedLabelBoxes = [];
 
             worldData.features.forEach((feature, index) => {
                 const { properties, geometry } = feature;
                 if (!geometry || properties.ISO_A2 === '-99') return;
                 const countryCode = properties.ISO_A2;
                 const countryName = countryNames[countryCode] || properties.ADMIN;
 
                 const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                 path.setAttribute('d', geoJsonToSvgPath(geometry.coordinates, geometry.type));
                 path.setAttribute('class', 'country');
                 path.setAttribute('fill', pastelColors[index % pastelColors.length]);
                 path.dataset.countryCode = countryCode;
                 countryGroup.appendChild(path);
 
                 if (countryName) {
                     const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                     label.setAttribute('class', 'country-label'); label.textContent = countryName; label.dataset.countryCode = countryCode;
-                    labelGroup.appendChild(label); 
+                    label.dataset.area = properties.calculatedArea || 0;
+                    labelGroup.appendChild(label);
 
-                    const largestPartCoords = geometry.type === 'Polygon' ? geometry.coordinates[0] : geometry.coordinates.reduce((a, b) => a.flat().length > b.flat().length ? a : b)[0];
-                    const projectedPolygon = largestPartCoords.map(p => mercatorProjection(p[0], p[1]));
+                    const largestPolygon = geometry.type === 'Polygon'
+                        ? geometry.coordinates
+                        : geometry.coordinates.reduce((largest, polygon) => {
+                            const largestLength = largest?.[0]?.length || 0;
+                            const polygonLength = polygon?.[0]?.length || 0;
+                            return polygonLength > largestLength ? polygon : largest;
+                        }, geometry.coordinates[0]);
+                    const largestPartCoords = largestPolygon[0] || [];
                     const centerLonLat = getPolygonCenter(largestPartCoords);
                     const [cx, cy] = mercatorProjection(centerLonLat[0], centerLonLat[1]);
-                    
-                    const labelBBox = label.getBBox(); const countryBBox = path.getBBox();
-                    let needsLeaderLine = (countryBBox.width < labelBBox.width || countryBBox.height < labelBBox.height);
-                    let bestPos = null;
-                    const checkPosition = (x, y) => {
-                        const testBox = { x: x - labelBBox.width / 2, y: y - labelBBox.height / 2, width: labelBBox.width, height: labelBBox.height };
-                        return !placedLabelBoxes.some(placedBox => isOverlapping(testBox, placedBox));
-                    };
-
-                    if (checkPosition(cx, cy)) {
-                        bestPos = { x: cx, y: cy };
-                    } else {
-                        const searchRadius = Math.max(countryBBox.width, countryBBox.height, 30);
-                        for (let r = 5; r < searchRadius && !bestPos; r += 5) {
-                            for (let angle = 0; angle < Math.PI * 2 && !bestPos; angle += Math.PI / 8) {
-                                const testX = cx + r * Math.cos(angle); const testY = cy + r * Math.sin(angle);
-                                if (checkPosition(testX, testY)) bestPos = { x: testX, y: testY };
-                            }
-                        }
-                    }
-
-                    if (bestPos) {
-                        label.setAttribute('x', bestPos.x); label.setAttribute('y', bestPos.y);
-                        if (!needsLeaderLine && !pointInPolygon([bestPos.x, bestPos.y], projectedPolygon)) needsLeaderLine = true;
-                    } else {
-                        needsLeaderLine = true;
-                        label.setAttribute('x', cx + countryBBox.width / 2 + labelBBox.width / 2 + 5); label.setAttribute('y', cy);
-                    }
-                    
-                    const finalBBox = label.getBBox();
-                    placedLabelBoxes.push({ x: finalBBox.x - 5, y: finalBBox.y - 5, width: finalBBox.width + 10, height: finalBBox.height + 10 });
-
-                    if (needsLeaderLine) {
-                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
-                        line.setAttribute('x1', cx); line.setAttribute('y1', cy);
-                        line.setAttribute('x2', label.getAttribute('x') - (finalBBox.width / 2) * (label.getAttribute('x') > cx ? 1 : -1));
-                        line.setAttribute('y2', label.getAttribute('y'));
-                        line.setAttribute('class', 'leader-line');
-                        labelGroup.insertBefore(line, label);
-                        const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
-                        dot.setAttribute('cx', cx); dot.setAttribute('cy', cy); dot.setAttribute('r', 1.5);
-                        dot.setAttribute('class', 'leader-dot');
-                        labelGroup.insertBefore(dot, line);
-                    }
+                    label.setAttribute('x', cx);
+                    label.setAttribute('y', cy);
                 }
             });
 
             countryGroup.querySelectorAll('.country').forEach(path => { path.addEventListener('mouseover', handleCountryHover); path.addEventListener('mouseout', handleCountryHover); });
             drawGridLines();
+            scheduleLabelAndListUpdate();
         }
         
         function handleCountryHover(event) {
             const code = event.target.dataset.countryCode; if (!code) return;
             const label = document.querySelector(`.country-label[data-country-code="${code}"]`);
             if (event.type === 'mouseover') { event.target.classList.add('country-hover'); if (label) label.classList.add('label-hover'); } 
             else { event.target.classList.remove('country-hover'); if (label) label.classList.remove('label-hover'); }
         }
         
         const getPolygonCenter = coords => {
             let lonMin = 180, latMin = 90, lonMax = -180, latMax = -90;
             coords.forEach(p => {
                 if (p[0] < lonMin) lonMin = p[0]; if (p[1] < latMin) latMin = p[1];
                 if (p[0] > lonMax) lonMax = p[0]; if (p[1] > latMax) latMax = p[1];
             });
             return [(lonMin + lonMax) / 2, (latMin + latMax) / 2];
         };
 
         function drawGridLines() {
             const grid = document.getElementById('gridLines'); grid.innerHTML = '';
             for (let lon = -180; lon <= 180; lon += 30) {
                 const path = document.createElementNS('http://www.w3.org/2000/svg', 'path'); let d = 'M';
                 for (let lat = -85; lat <= 85; lat += 5) d += mercatorProjection(lon, lat).join(',') + 'L';
                 path.setAttribute('d', d.slice(0, -1)); path.setAttribute('class', 'grid-line'); grid.appendChild(path);
             }
             for (let lat = -60; lat <= 80; lat += 30) {
                 const path = document.createElementNS('http://www.w3.org/2000/svg', 'path'); let d = 'M';
                 for (let lon = -180; lon <= 180; lon += 5) d += mercatorProjection(lon, lat).join(',') + 'L';
                 path.setAttribute('d', d.slice(0, -1)); path.setAttribute('class', 'grid-line'); grid.appendChild(path);
             }
         }
         
         function updateDynamicSizes() {
             const optimalFontSize = Math.max(8, Math.min(48, Math.round(mapWidth / 183)));
             document.getElementById('fontSize').value = optimalFontSize;
             updateLabelStyles();
         }
-        
+
         function updateLabelStyles() {
             const fontSize = document.getElementById('fontSize').value;
             const strokeWidth = fontSize / 10; // [수정] 테두리 두께 1/10로 변경
             document.getElementById('fontSizeValue').textContent = fontSize + 'px';
             document.querySelectorAll('.country-label').forEach(label => {
                 label.setAttribute('font-size', fontSize);
                 label.setAttribute('stroke-width', strokeWidth);
             });
             const labelGroup = document.getElementById('countryLabels');
             if (labelGroup) labelGroup.style.display = document.getElementById('showLabels').checked ? '' : 'none';
+            scheduleLabelAndListUpdate();
         }
-        
+
+        function updateLabelVisibility() {
+            const labelGroup = document.getElementById('countryLabels');
+            if (!labelGroup) return;
+            const showLabels = document.getElementById('showLabels').checked;
+            const labels = Array.from(labelGroup.querySelectorAll('.country-label'));
+
+            if (!showLabels) {
+                labels.forEach(label => { label.style.display = 'none'; });
+                return;
+            }
+
+            labels.forEach(label => { label.style.display = ''; });
+            const sortedLabels = labels.sort((a, b) => (parseFloat(b.dataset.area) || 0) - (parseFloat(a.dataset.area) || 0));
+            const placedRects = [];
+
+            sortedLabels.forEach(label => {
+                const rect = label.getBoundingClientRect();
+                const hasSize = rect.width > 0 && rect.height > 0;
+                const overlaps = placedRects.some(existing => !(rect.right <= existing.left || rect.left >= existing.right || rect.bottom <= existing.top || rect.top >= existing.bottom));
+
+                if (hasSize && !overlaps) {
+                    label.style.display = '';
+                    placedRects.push(rect);
+                } else if (!hasSize) {
+                    label.style.display = '';
+                } else {
+                    label.style.display = 'none';
+                }
+            });
+        }
+
+        function scheduleLabelAndListUpdate() {
+            if (labelUpdatePending) return;
+            labelUpdatePending = true;
+            requestAnimationFrame(() => {
+                labelUpdatePending = false;
+                updateLabelVisibility();
+                updateCountryList();
+            });
+        }
+
+        function updateZoomDisplay() {
+            const zoomValue = document.getElementById('zoomValue');
+            if (zoomValue) {
+                const percent = Math.round(currentScale * 100);
+                zoomValue.textContent = `${percent}%`;
+                if (zoomInput && document.activeElement !== zoomInput) {
+                    zoomInput.value = percent;
+                }
+            }
+        }
+
         function updateCountryList() {
             const listUl = document.getElementById('countryList');
-            const mapContainer = document.getElementById('mapContainer');
+            if (!svg || !listUl) return;
             const svgRect = svg.getBoundingClientRect();
-            
+
             const visibleCountries = new Set();
 
             document.querySelectorAll('.country-label').forEach(label => {
+                if (label.style.display === 'none') return;
                 const labelRect = label.getBoundingClientRect();
                 // 레이블이 SVG 뷰포트 안에 들어오는지 확인
                 if (labelRect.right > svgRect.left && labelRect.left < svgRect.right &&
                     labelRect.bottom > svgRect.top && labelRect.top < svgRect.bottom) {
                     visibleCountries.add(label.textContent);
                 }
             });
             
             listUl.innerHTML = '';
             Array.from(visibleCountries).sort((a, b) => a.localeCompare(b, 'ko')).forEach(name => {
                 const li = document.createElement('li');
                 li.textContent = name;
                 listUl.appendChild(li);
             });
         }
 
         document.getElementById('showLabels').addEventListener('change', updateLabelStyles);
         document.getElementById('fontSize').addEventListener('input', updateLabelStyles);
         
-        document.getElementById('mapSize').addEventListener('input', function() {
-            const wrapper = document.querySelector('.map-wrapper');
-            const oldWidth = mapWidth;
-            // 현재 스크롤 위치 비율 계산
-            const scrollLeftRatio = wrapper.scrollLeft / (mapWidth - wrapper.clientWidth);
-            const scrollTopRatio = wrapper.scrollTop / (mapHeight - wrapper.clientHeight);
-
-            mapWidth = parseInt(this.value);
-            mapHeight = mapWidth / 2;
-            document.getElementById('mapSizeValue').textContent = `${mapWidth}x${mapHeight}px`;
-            
-            initMap();
-            
-            requestAnimationFrame(() => {
-                // 새로운 스크롤 위치 계산
-                const newScrollLeft = scrollLeftRatio * (mapWidth - wrapper.clientWidth);
-                const newScrollTop = scrollTopRatio * (mapHeight - wrapper.clientHeight);
-
-                wrapper.scrollLeft = newScrollLeft || 0;
-                wrapper.scrollTop = newScrollTop || 0;
-            });
-        });
-        
         document.getElementById('toggleListBtn').addEventListener('click', () => {
             const panel = document.getElementById('countryListPanel');
             panel.classList.toggle('hidden');
             if (!panel.classList.contains('hidden')) {
-                updateCountryList(); // 목록이 열릴 때 업데이트
+                scheduleLabelAndListUpdate(); // 목록이 열릴 때 업데이트
             }
         });
 
-        const svg = document.getElementById('worldMap');
-        
+        const getViewportCenterPoint = () => {
+            const rect = svg.getBoundingClientRect();
+            const point = svg.createSVGPoint();
+            point.x = rect.width / 2;
+            point.y = rect.height / 2;
+            const ctm = svg.getScreenCTM();
+            return ctm ? point.matrixTransform(ctm.inverse()) : { x: mapWidth / 2, y: mapHeight / 2 };
+        };
+
+        const clampZoomPercent = value => Math.min(MAX_SCALE * 100, Math.max(MIN_SCALE * 100, value));
+
+        const changeZoomByStep = step => {
+            const centerPoint = getViewportCenterPoint();
+            const currentPercent = Math.round(currentScale * 100);
+            const targetPercent = clampZoomPercent(currentPercent + step);
+            applyZoom(targetPercent / 100, centerPoint);
+        };
+
+        document.getElementById('zoomInBtn').addEventListener('click', () => {
+            changeZoomByStep(5);
+        });
+
+        document.getElementById('zoomOutBtn').addEventListener('click', () => {
+            changeZoomByStep(-5);
+        });
+
+        if (zoomResetBtn) {
+            zoomResetBtn.addEventListener('click', () => {
+                currentScale = 1;
+                currentX = 0;
+                currentY = 0;
+                updateTransform();
+            });
+        }
+
+        if (zoomInput) {
+            zoomInput.addEventListener('change', () => {
+                const rawValue = parseFloat(zoomInput.value);
+                if (!Number.isFinite(rawValue) || rawValue <= 0) {
+                    updateZoomDisplay();
+                    return;
+                }
+                const clampedPercent = clampZoomPercent(rawValue);
+                const centerPoint = getViewportCenterPoint();
+                applyZoom(clampedPercent / 100, centerPoint);
+            });
+            zoomInput.addEventListener('keydown', event => {
+                if (event.key === 'Enter') {
+                    event.preventDefault();
+                    zoomInput.blur();
+                }
+            });
+        }
+
         const updateTransform = () => {
             ['gridLines', 'countries', 'countryLabels'].forEach(id => document.getElementById(id)?.setAttribute('transform', `translate(${currentX}, ${currentY}) scale(${currentScale})`));
-            requestAnimationFrame(updateCountryList); // [추가] 변환 후 국가 목록 업데이트
+            updateZoomDisplay();
+            scheduleLabelAndListUpdate();
         };
-        
+
+        const applyZoom = (targetScale, focusPoint) => {
+            const focus = focusPoint || { x: mapWidth / 2, y: mapHeight / 2 };
+            const clampedScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, targetScale));
+            const scaleRatio = clampedScale / currentScale;
+            currentX = focus.x - (focus.x - currentX) * scaleRatio;
+            currentY = focus.y - (focus.y - currentY) * scaleRatio;
+            currentScale = clampedScale;
+            updateTransform();
+        };
+
         svg.addEventListener('wheel', e => {
             e.preventDefault();
             const rect = svg.getBoundingClientRect();
-            const point = svg.createSVGPoint(); 
+            const point = svg.createSVGPoint();
             point.x = e.clientX - rect.left; point.y = e.clientY - rect.top;
-            
+
             // 현재 SVG 좌표계에서의 마우스 위치 계산
             const svgPoint = point.matrixTransform(svg.getScreenCTM().inverse());
-            
-            const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1;
-            const newScale = Math.max(0.5, Math.min(50, currentScale * scaleFactor));
 
-            // [수정] 줌 인/아웃 시 마우스 위치 중심으로 변환
-            currentX = svgPoint.x - (svgPoint.x - currentX) * (newScale / currentScale);
-            currentY = svgPoint.y - (svgPoint.y - currentY) * (newScale / currentScale);
-            currentScale = newScale;
-            updateTransform();
+            const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1;
+            const newScale = currentScale * scaleFactor;
+            applyZoom(newScale, svgPoint);
         });
 
         svg.addEventListener('mousedown', e => { isDragging = true; panStart.x = currentX; panStart.y = currentY; dragStart.x = e.clientX; dragStart.y = e.clientY; svg.style.cursor = 'grabbing'; });
         svg.addEventListener('mousemove', e => { if (isDragging) { const dx = e.clientX - dragStart.x; const dy = e.clientY - dragStart.y; currentX = panStart.x + dx; currentY = panStart.y + dy; updateTransform(); } });
-        const endDrag = () => { isDragging = false; svg.style.cursor = 'grab'; updateCountryList(); }; // [추가] 드래그 종료 후 국가 목록 업데이트
+        const endDrag = () => { isDragging = false; svg.style.cursor = 'grab'; scheduleLabelAndListUpdate(); }; // [추가] 드래그 종료 후 국가 목록 업데이트
         svg.addEventListener('mouseup', endDrag);
         svg.addEventListener('mouseleave', endDrag);
 
         const download = (url, filename) => { const a = document.createElement('a'); a.href = url; a.download = filename; a.click(); URL.revokeObjectURL(url); };
         function downloadSVG() {
             const svgEl = document.getElementById('worldMap');
             svgEl.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
             const svgData = svgEl.outerHTML;
             const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
             download(URL.createObjectURL(blob), 'world_map.svg');
         }
         function downloadPNG() {
             const svgEl = document.getElementById('worldMap');
             const canvas = document.createElement('canvas');
             canvas.width = mapWidth * 2; canvas.height = mapHeight * 2;
             const ctx = canvas.getContext('2d');
             const svgData = new XMLSerializer().serializeToString(svgEl);
             const img = new Image();
             img.onload = () => { ctx.drawImage(img, 0, 0, canvas.width, canvas.height); download(canvas.toDataURL('image/png'), 'world_map.png'); };
             img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgData)));
         }
         
         document.addEventListener('DOMContentLoaded', () => {
-            const mapWrapper = document.querySelector('.map-wrapper');
-            mapWidth = mapWrapper.clientWidth;
-            mapHeight = mapWidth / 2;
-            const mapSizeSlider = document.getElementById('mapSize');
-            mapSizeSlider.value = mapWidth;
-            document.getElementById('mapSizeValue').textContent = `${mapWidth}x${mapHeight}px`;
+            mapWidth = BASE_MAP_WIDTH;
+            mapHeight = BASE_MAP_HEIGHT;
             loadWorldData();
         });
     </script>
 </body>
 </html>
 
EOF
)
